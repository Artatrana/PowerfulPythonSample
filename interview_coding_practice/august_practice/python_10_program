
## ðŸŽ¯ **Interview Programs Overview:**

### **1. Find All Anagrams in a String**
- **Logic**: Use sliding window to find all anagram positions
- **Concepts**: Hash maps, sliding window technique
- **Time**: O(n), **Space**: O(1)

### **2. Merge Overlapping Intervals**
- **Logic**: Sort intervals, then merge overlapping ones
- **Concepts**: Sorting, greedy algorithm
- **Time**: O(n log n), **Space**: O(1)

### **3. Longest Substring Without Repeating Characters**
- **Logic**: Two pointers with hash map to track character positions
- **Concepts**: Sliding window, hash maps
- **Time**: O(n), **Space**: O(min(m,n))

### **4. Group Anagrams**
- **Logic**: Use sorted string as key to group anagrams
- **Concepts**: Hash maps, string manipulation
- **Time**: O(n Ã— k log k), **Space**: O(n Ã— k)

### **5. Validate Binary Search Tree**
- **Logic**: Check each node is within valid range recursively
- **Concepts**: Tree traversal, recursion, BST properties
- **Time**: O(n), **Space**: O(h)

### **6. Top K Frequent Elements**
- **Logic**: Count frequencies, use min-heap to find top K
- **Concepts**: Hash maps, heaps, priority queues
- **Time**: O(n log k), **Space**: O(n)

### **7. Word Break Problem**
- **Logic**: Dynamic programming to check if string can be segmented
- **Concepts**: DP, string processing
- **Time**: O(nÂ² Ã— m), **Space**: O(n)

### **8. Minimum Window Substring**
- **Logic**: Expand right, contract left using sliding window
- **Concepts**: Two pointers, sliding window
- **Time**: O(|s| + |t|), **Space**: O(|s| + |t|)

### **9. Coin Change Problem**
- **Logic**: DP to find minimum coins for each amount
- **Concepts**: Dynamic programming, optimization
- **Time**: O(amount Ã— coins), **Space**: O(amount)

### **10. LRU Cache Implementation**
- **Logic**: Hash map + doubly linked list for O(1) operations
- **Concepts**: Data structures, object-oriented design
- **Time**: O(1) for get/put, **Space**: O(capacity)

## ðŸ”‘ **Key Interview Topics Covered:**

- **Data Structures**: Arrays, Hash Maps, Trees, Linked Lists, Heaps
- **Algorithms**: Two Pointers, Sliding Window, DP, DFS/BFS, Greedy
- **Patterns**: Fast/Slow Pointers, Merge Intervals, Subarray Problems
- **Complexity Analysis**: Time and space complexity for each solution

## ðŸ’¡ **Why These Are Perfect for Interviews:**

1. **Medium Complexity**: Not too easy, not too hard
2. **Common Patterns**: Teach transferable problem-solving techniques
3. **Real-world Applications**: Similar to actual system design problems
4. **Clear Logic**: Each solution explained in simple English
5. **Optimal Solutions**: Industry-standard approaches with good complexity

Each program includes detailed comments explaining the logic step-by-step, making them perfect for interview preparation and understanding core algorithmic concepts!